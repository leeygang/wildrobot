"""Robot configuration management for WildRobot.

This module provides utilities to load and manage robot-specific configuration
from robot_config.yaml (generated by assets/post_process.py).

All other modules should import robot configuration through this module instead of
hardcoding robot-specific values.

Usage:
    from playground_amp.configs.robot_config import load_robot_config, get_robot_config, RobotConfig

    # Load robot config (path passed from train.py)
    robot_config = load_robot_config("assets/robot_config.yaml")

    # Access robot properties
    print(robot_config.action_dim)  # 9
    print(robot_config.actuator_names)  # ['waist_yaw', 'left_hip_pitch', ...]

    # Get cached config (after loading)
    robot_cfg = get_robot_config()
"""

from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import yaml


@dataclass
class RobotConfig:
    """Robot configuration loaded from robot_config.yaml.

    This dataclass provides easy access to all robot-specific parameters
    extracted from the MuJoCo XML file.

    Attributes:
        robot_name: Name of the robot model
        actuator_names: List of actuator names in order
        actuator_joints: List of joint names corresponding to actuators
        action_dim: Number of actuators (action space dimension)
        observation_dim: Total observation dimension
        amp_feature_dim: AMP feature dimension
        floating_base_name: Name of the floating base joint
        floating_base_body: Name of the root body
        joint_names: List of all joint names
        joint_limits: Dict mapping joint name to (min, max) limits
        observation_indices: Dict mapping observation component to (start, end) indices
        sensors: Dict mapping sensor type to list of sensor info
    """

    robot_name: str
    actuator_names: List[str]
    actuator_joints: List[str]
    action_dim: int
    observation_dim: int
    amp_feature_dim: int
    floating_base_name: Optional[str]
    floating_base_body: Optional[str]
    floating_base_qpos_dim: int
    floating_base_qvel_dim: int
    joint_names: List[str]
    joint_limits: Dict[str, Tuple[float, float]]
    observation_indices: Dict[str, Dict[str, int]]
    observation_breakdown: Dict[str, int]
    amp_feature_breakdown: Dict[str, int]
    sensors: Dict[str, List[Dict[str, Any]]]

    # Feet configuration (for contact detection)
    feet_sites: List[str]
    feet_left_geoms: List[str]
    feet_right_geoms: List[str]
    feet_all_geoms: List[str]
    # Foot body names (for slip/clearance computation)
    left_foot_body: str
    right_foot_body: str

    raw_config: Dict[str, Any] = field(repr=False)

    # Sensor names (derived from sensors dict for convenience)
    @property
    def gravity_sensor(self) -> str:
        """Get gravity/up-vector sensor name."""
        framezaxis = self.sensors.get("framezaxis", [])
        for s in framezaxis:
            if (
                "pelvis" in s.get("name", "").lower()
                or "upvector" in s.get("name", "").lower()
            ):
                return s["name"]
        return framezaxis[0]["name"] if framezaxis else ""

    @property
    def global_linvel_sensor(self) -> str:
        """Get global linear velocity sensor name."""
        framelinvel = self.sensors.get("framelinvel", [])
        for s in framelinvel:
            if (
                "pelvis" in s.get("name", "").lower()
                and "global" in s.get("name", "").lower()
            ):
                return s["name"]
        return framelinvel[0]["name"] if framelinvel else ""

    @property
    def global_angvel_sensor(self) -> str:
        """Get global angular velocity sensor name."""
        frameangvel = self.sensors.get("frameangvel", [])
        for s in frameangvel:
            if (
                "pelvis" in s.get("name", "").lower()
                and "global" in s.get("name", "").lower()
            ):
                return s["name"]
        return frameangvel[0]["name"] if frameangvel else ""

    @property
    def local_linvel_sensor(self) -> str:
        """Get local linear velocity sensor name."""
        velocimeter = self.sensors.get("velocimeter", [])
        for s in velocimeter:
            if "pelvis" in s.get("name", "").lower():
                return s["name"]
        return velocimeter[0]["name"] if velocimeter else ""

    @property
    def gyro_sensor_names(self) -> List[str]:
        """Get list of gyro sensor names."""
        return [s["name"] for s in self.sensors.get("gyro", [])]

    @property
    def accelerometer_sensor_names(self) -> List[str]:
        """Get list of accelerometer sensor names."""
        return [s["name"] for s in self.sensors.get("accelerometer", [])]

    @classmethod
    def from_yaml(cls, config_path: str | Path) -> "RobotConfig":
        """Load robot configuration from YAML file.

        Args:
            config_path: Path to robot_config.yaml

        Returns:
            RobotConfig instance
        """
        with open(config_path, "r") as f:
            config = yaml.safe_load(f)

        # Extract actuator info
        actuators = config.get("actuators", {})
        actuator_names = actuators.get("names", [])
        actuator_joints = actuators.get("joints", [])
        action_dim = actuators.get("count", len(actuator_names))

        # Extract dimensions
        dims = config.get("dimensions", {})
        observation_dim = dims.get("observation_dim", 38)
        amp_feature_dim = dims.get("amp_feature_dim", 29)

        # Extract floating base info
        fb = config.get("floating_base", {}) or {}
        floating_base_name = fb.get("name")
        floating_base_body = fb.get("root_body")
        floating_base_qpos_dim = fb.get("qpos_dim", 7)
        floating_base_qvel_dim = fb.get("qvel_dim", 6)

        # Extract joint info
        joints = config.get("joints", {})
        joint_names = [j for j in joints.get("names", []) if j is not None]

        # Build joint limits dict
        joint_limits = {}
        for joint_detail in joints.get("details", []):
            name = joint_detail.get("name")
            if name and "range" in joint_detail:
                joint_limits[name] = tuple(joint_detail["range"])

        # Extract observation indices
        observation_indices = config.get("observation_indices", {})
        observation_breakdown = dims.get("observation_breakdown", {})
        amp_feature_breakdown = dims.get("amp_feature_breakdown", {})

        # Extract sensors
        sensors = config.get("sensors", {})

        # Extract feet configuration
        feet = config.get("feet", {})
        feet_sites = feet.get("sites", [])
        feet_left_geoms = feet.get("left_geoms", [])
        feet_right_geoms = feet.get("right_geoms", [])
        feet_all_geoms = feet.get("all_geoms", [])
        left_foot_body = feet.get("left_foot_body", "left_foot")
        right_foot_body = feet.get("right_foot_body", "right_foot")

        return cls(
            robot_name=config.get("robot_name", "unknown"),
            actuator_names=actuator_names,
            actuator_joints=actuator_joints,
            action_dim=action_dim,
            observation_dim=observation_dim,
            amp_feature_dim=amp_feature_dim,
            floating_base_name=floating_base_name,
            floating_base_body=floating_base_body,
            floating_base_qpos_dim=floating_base_qpos_dim,
            floating_base_qvel_dim=floating_base_qvel_dim,
            joint_names=joint_names,
            joint_limits=joint_limits,
            observation_indices=observation_indices,
            observation_breakdown=observation_breakdown,
            amp_feature_breakdown=amp_feature_breakdown,
            sensors=sensors,
            feet_sites=feet_sites,
            feet_left_geoms=feet_left_geoms,
            feet_right_geoms=feet_right_geoms,
            feet_all_geoms=feet_all_geoms,
            left_foot_body=left_foot_body,
            right_foot_body=right_foot_body,
            raw_config=config,
        )

    def get_obs_slice(self, component: str) -> slice:
        """Get slice for extracting observation component.

        Args:
            component: Name of observation component (e.g., 'joint_positions')

        Returns:
            slice object for indexing into observation array
        """
        indices = self.observation_indices.get(component, {})
        return slice(indices.get("start", 0), indices.get("end", 0))

    def get_sensor_names(self, sensor_type: str) -> List[str]:
        """Get list of sensor names for a given type.

        Args:
            sensor_type: Sensor type (e.g., 'gyro', 'accelerometer')

        Returns:
            List of sensor names
        """
        return [s["name"] for s in self.sensors.get(sensor_type, [])]


# =============================================================================
# Cached Config and Accessor Functions
# =============================================================================

_robot_config: Optional[RobotConfig] = None


def load_robot_config(config_path: str | Path) -> RobotConfig:
    """Load robot configuration.

    Caches the config after first load for efficiency.

    Args:
        config_path: Path to robot_config.yaml (required).

    Returns:
        RobotConfig instance
    """
    global _robot_config

    # Return cached if already loaded
    if _robot_config is not None:
        return _robot_config

    _robot_config = RobotConfig.from_yaml(config_path)
    return _robot_config


def get_robot_config() -> RobotConfig:
    """Get cached robot configuration.

    Raises:
        RuntimeError: If config hasn't been loaded yet
    """
    if _robot_config is None:
        raise RuntimeError(
            "Robot config not loaded. Call load_robot_config(path) first."
        )
    return _robot_config


def clear_robot_config_cache() -> None:
    """Clear cached robot configuration."""
    global _robot_config
    _robot_config = None


def get_obs_indices(component: str) -> Tuple[int, int]:
    """Get (start, end) indices for an observation component.

    Args:
        component: Name of observation component

    Returns:
        Tuple of (start, end) indices
    """
    robot_cfg = get_robot_config()
    indices = robot_cfg.observation_indices.get(component, {})
    return indices.get("start", 0), indices.get("end", 0)
