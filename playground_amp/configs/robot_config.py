"""Robot configuration management for WildRobot.

This module provides utilities to load and manage robot-specific configuration
from robot_config.yaml (generated by assets/post_process.py).

All other modules should import robot configuration through this module instead of
hardcoding robot-specific values.

Usage:
    from playground_amp.configs.robot_config import load_robot_config, get_robot_config, RobotConfig

    # Load robot config (path passed from train.py)
    robot_config = load_robot_config("assets/robot_config.yaml")

    # Access robot properties
    print(robot_config.action_dim)  # 9
    print(robot_config.actuator_names)  # ['waist_yaw', 'left_hip_pitch', ...]

    # Get cached config (after loading)
    robot_cfg = get_robot_config()
"""

from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import yaml


@dataclass
class RobotConfig:
    """Robot configuration loaded from robot_config.yaml.

    This dataclass provides easy access to all robot-specific parameters
    extracted from the MuJoCo XML file.

    Attributes:
        robot_name: Name of the robot model
        actuator_names: List of actuator names in order
        actuator_joints: List of joint names corresponding to actuators
        action_dim: Number of actuators (action space dimension)
        observation_dim: Total observation dimension
        amp_feature_dim: AMP feature dimension
        floating_base_name: Name of the floating base joint
        floating_base_body: Name of the root body
        joint_limits: Dict mapping joint name to (min, max) limits
        observation_indices: Dict mapping observation component to (start, end) indices
    """

    robot_name: str
    actuator_names: List[str]
    actuator_joints: List[str]
    action_dim: int
    observation_dim: int
    amp_feature_dim: int
    floating_base_name: Optional[str]
    floating_base_body: Optional[str]
    floating_base_qpos_dim: int
    floating_base_qvel_dim: int
    joint_limits: Dict[str, Tuple[float, float]]
    observation_indices: Dict[str, Dict[str, int]]
    observation_breakdown: Dict[str, int]
    amp_feature_breakdown: Dict[str, int]

    # Feet configuration (for contact detection)
    feet_left_geoms: List[str]
    feet_right_geoms: List[str]
    # Foot body names (for slip/clearance computation)
    left_foot_body: str
    right_foot_body: str

    # v0.11.0: Actuated joints config for CAL (Control Abstraction Layer)
    actuated_joints: List[Dict[str, Any]] = field(default_factory=list)

    # Internal: raw YAML config for property access (not part of public API)
    _raw_config: Dict[str, Any] = field(default_factory=dict, repr=False)

    # =========================================================================
    # Root Sensor Properties (from root.sensors config - single source of truth)
    # =========================================================================

    def _get_root_sensor(self, key: str) -> str:
        """Get a root sensor name, raising error if not configured."""
        root = self._raw_config.get("root_spec")
        if not root:
            raise ValueError("robot_config.yaml missing 'root_spec' section")
        sensors = root.get("sensors")
        if not sensors:
            raise ValueError("robot_config.yaml missing 'root_spec.sensors' section")
        if key not in sensors:
            raise ValueError(f"robot_config.yaml missing 'root_spec.sensors.{key}'")
        return sensors[key]

    @property
    def gravity_sensor(self) -> str:
        """Get gravity/up-vector sensor name."""
        return self._get_root_sensor("gravity")

    @property
    def global_angvel_sensor(self) -> str:
        """Get global angular velocity sensor name."""
        return self._get_root_sensor("global_angvel")

    @property
    def local_linvel_sensor(self) -> str:
        """Get local linear velocity sensor name."""
        return self._get_root_sensor("local_linvel")

    @property
    def orientation_sensor(self) -> str:
        """Get root orientation sensor name (framequat from chest IMU)."""
        return self._get_root_sensor("orientation")

    @property
    def root_gyro_sensor(self) -> str:
        """Get root angular velocity sensor name (gyro from chest IMU)."""
        return self._get_root_sensor("gyro")

    @property
    def root_accel_sensor(self) -> str:
        """Get root accelerometer sensor name (from chest IMU)."""
        return self._get_root_sensor("accel")

    def get_actuator_index(self, name: str) -> int:
        """Get actuator index by name (order matches actuator_names)."""
        try:
            return self.actuator_names.index(name)
        except ValueError as exc:
            raise ValueError(
                f"Actuator '{name}' not found in actuator_names: {self.actuator_names}"
            ) from exc

    def get_hip_pitch_indices(self) -> Tuple[int, int]:
        """Get (left, right) hip pitch actuator indices."""
        return (
            self.get_actuator_index("left_hip_pitch"),
            self.get_actuator_index("right_hip_pitch"),
        )

    def get_knee_pitch_indices(self) -> Tuple[int, int]:
        """Get (left, right) knee pitch actuator indices."""
        return (
            self.get_actuator_index("left_knee_pitch"),
            self.get_actuator_index("right_knee_pitch"),
        )

    def _get_foot_spec(self, side: str, key: str) -> str:
        """Get a foot spec value, raising error if not configured."""
        feet_config = self._raw_config.get("foot_specs")
        if not feet_config:
            raise ValueError("robot_config.yaml missing 'foot_specs' section")
        foot = feet_config.get(side)
        if not foot:
            raise ValueError(f"robot_config.yaml missing 'foot_specs.{side}' section")
        if key not in foot:
            raise ValueError(f"robot_config.yaml missing 'foot_specs.{side}.{key}'")
        return foot[key]

    def get_foot_geom_names(self) -> Tuple[str, str, str, str]:
        """Get foot geom names as (left_toe, left_heel, right_toe, right_heel)."""
        return (
            self._get_foot_spec("left", "toe"),
            self._get_foot_spec("left", "heel"),
            self._get_foot_spec("right", "toe"),
            self._get_foot_spec("right", "heel"),
        )

    @property
    def contact_scale(self) -> float:
        """Get contact force normalization scale for tanh.

        Used by CAL to normalize foot contact forces: tanh(force / scale)
        10.0 means: 10N → tanh(1) ≈ 0.76, 20N → tanh(2) ≈ 0.96
        """
        feet_config = self._raw_config.get("foot_specs")
        if not feet_config:
            raise ValueError("robot_config.yaml missing 'foot_specs' section")
        if "contact_scale" not in feet_config:
            raise ValueError("robot_config.yaml missing 'foot_specs.contact_scale'")
        return feet_config["contact_scale"]

    @classmethod
    def from_yaml(cls, config_path: str | Path) -> "RobotConfig":
        """Load robot configuration from YAML file.

        Args:
            config_path: Path to robot_config.yaml

        Returns:
            RobotConfig instance
        """
        with open(config_path, "r") as f:
            config = yaml.safe_load(f)

        # v0.11.0: Extract actuated joints config (single source of truth)
        actuated_joints = config.get("actuated_joint_specs", [])

        # Derive actuator info from actuated_joints
        actuator_names = [j["name"] for j in actuated_joints]
        actuator_joints = actuator_names  # For position-controlled, name == joint
        action_dim = len(actuated_joints)

        # Extract breakdowns (source of truth)
        observation_breakdown = config.get("observation_breakdown", {})
        amp_feature_breakdown = config.get("amp_feature_breakdown", {})

        # Compute dimensions from breakdowns
        observation_dim = (
            sum(observation_breakdown.values()) if observation_breakdown else 38
        )
        amp_feature_dim = (
            sum(amp_feature_breakdown.values()) if amp_feature_breakdown else 29
        )

        # Compute observation indices from breakdown
        obs_idx = 0
        observation_indices = {}
        for key, size in observation_breakdown.items():
            observation_indices[key] = {"start": obs_idx, "end": obs_idx + size}
            obs_idx += size

        # Extract root info (merged floating_base + root_imu)
        root_config = config.get("root_spec", {}) or {}
        floating_base_name = root_config.get("joint")
        floating_base_body = root_config.get("body")
        floating_base_qpos_dim = root_config.get("qpos_dim", 7)
        floating_base_qvel_dim = root_config.get("qvel_dim", 6)

        # Build joint limits dict from actuated_joints
        joint_limits = {}
        for joint in actuated_joints:
            name = joint.get("name")
            if name and "range" in joint:
                joint_limits[name] = tuple(joint["range"])

        # Extract feet configuration (split left/right)
        feet = config.get("foot_specs", {})
        left_foot = feet.get("left", {})
        right_foot = feet.get("right", {})

        # Build legacy fields for backward compatibility
        left_foot_body = left_foot.get("body", "left_foot")
        right_foot_body = right_foot.get("body", "right_foot")
        feet_left_geoms = [left_foot.get("heel"), left_foot.get("toe")]
        feet_left_geoms = [g for g in feet_left_geoms if g]
        feet_right_geoms = [right_foot.get("toe"), right_foot.get("heel")]
        feet_right_geoms = [g for g in feet_right_geoms if g]
        # v0.11.0: Extract actuated joints config for CAL
        actuated_joints = config.get("actuated_joint_specs", [])

        return cls(
            robot_name=config.get("robot_name", "unknown"),
            actuator_names=actuator_names,
            actuator_joints=actuator_joints,
            action_dim=action_dim,
            observation_dim=observation_dim,
            amp_feature_dim=amp_feature_dim,
            floating_base_name=floating_base_name,
            floating_base_body=floating_base_body,
            floating_base_qpos_dim=floating_base_qpos_dim,
            floating_base_qvel_dim=floating_base_qvel_dim,
            joint_limits=joint_limits,
            observation_indices=observation_indices,
            observation_breakdown=observation_breakdown,
            amp_feature_breakdown=amp_feature_breakdown,
            feet_left_geoms=feet_left_geoms,
            feet_right_geoms=feet_right_geoms,
            left_foot_body=left_foot_body,
            right_foot_body=right_foot_body,
            actuated_joints=actuated_joints,
            _raw_config=config,
        )


# =============================================================================
# Cached Config and Accessor Functions
# =============================================================================

_robot_config: Optional[RobotConfig] = None


def load_robot_config(config_path: str | Path) -> RobotConfig:
    """Load robot configuration.

    Caches the config after first load for efficiency.

    Args:
        config_path: Path to robot_config.yaml (required).

    Returns:
        RobotConfig instance
    """
    global _robot_config

    # Return cached if already loaded
    if _robot_config is not None:
        return _robot_config

    _robot_config = RobotConfig.from_yaml(config_path)
    return _robot_config


def get_robot_config() -> RobotConfig:
    """Get cached robot configuration.

    Raises:
        RuntimeError: If config hasn't been loaded yet
    """
    if _robot_config is None:
        raise RuntimeError(
            "Robot config not loaded. Call load_robot_config(path) first."
        )
    return _robot_config


def clear_robot_config_cache() -> None:
    """Clear cached robot configuration."""
    global _robot_config
    _robot_config = None


def get_obs_indices(component: str) -> Tuple[int, int]:
    """Get (start, end) indices for an observation component.

    Args:
        component: Name of observation component

    Returns:
        Tuple of (start, end) indices
    """
    robot_cfg = get_robot_config()
    indices = robot_cfg.observation_indices.get(component, {})
    return indices.get("start", 0), indices.get("end", 0)
